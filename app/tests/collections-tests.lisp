; Common Lisp - comments style conventions
; title       ;;;; Short title for block of code
; intro       ;;;  Description before block of code
; state       ;;   State of program or following code
; explanation ;    Regarding line on which it appears

(in-package :introlisp.intro/test)

(5am:def-suite tc-collections
	:description "Collections Tests suite")
(5am:in-suite tc-collections)

(5am:def-fixture fixc-collections ()
	(format t "~tSetUp-->~%")
	(&body)
	(format t "~t <--TearDown~%"))

(5am:test (test-lists :fixture fixc-collections)
	(let ((lst '(2 1 0 4 3)))
		(5am:is (equal (list 1) '(1)) "make-list")
		(5am:is (equal lst '(2 1 0 4 3)) "equal")
		(5am:is (not (equal lst '(2 1 0))) "inequal")
		(5am:is (null '()) "empty")
		(5am:is (equal 2 (car lst)) "head")
		(5am:is (equal 2 (nth 0 lst)) "nth")
		(5am:is (equal 5 (length lst)) "length")
		(5am:is (equal (append lst '(9 9 9 9)) '(2 1 0 4 3 9 9 9 9)) "append")
		(5am:is (equal (reverse lst) '(3 4 0 1 2)) "reverse")
		(5am:is (not (equal '() (member 1 lst))) "member")
		(5am:is (some (lambda (e) (= 1 (mod e 2))) lst) "exists")
		(5am:is (every (lambda (e) (= 0 (mod e 2))) '(6 4 2)) "for-all")
		(5am:is (equal '(2 0 4) (remove-if-not (lambda (e) 
			(= 0 (mod e 2))) lst)) "filter")
		(5am:is (equal '(1 3) (remove-if (lambda (e) 
			(= 0 (mod e 2))) lst)) "remove")
		(5am:is (equal -10 (reduce (lambda (a e) (- a e)) lst 
			:initial-value 0)) "fold-left")
		(5am:is (equal 0 (reduce (lambda (e a) (- e a)) lst 
			:initial-value 0 :from-end t)) "fold-right")
		(5am:is (equal '(4 3 2 6 5) (map 'list (lambda (e) 
			(+ e 2)) lst)) "map")
		(5am:is (equalp #(2 1 0 4 3) (make-array (list (length lst)) 
			:initial-contents lst)) "to-array (using make-array)")
		(5am:is (equalp #(2 1 0 4 3) (map 'vector #'identity lst)) 
			"to-vector (using map)")
		(5am:is (equal '(4 3 2 1 0) (sort lst #'>)) "sort")
    ))

(5am:test (test-vectors :fixture fixc-collections)
	(let ((vec #(2 1 0 4 3)))
		(5am:is (equalp (vector 1) #(1)) "make-array")
		(5am:is (equalp vec #(2 1 0 4 3)) "equal")
		(5am:is (equal 2 (elt vec 0)) "nth")
		(5am:is (equal 5 (length vec)) "length")
		(5am:is (equalp (concatenate 'vector vec #(9 9 9 9)) #(2 1 0 4 3 9 9 9 9)) "append")
		(5am:is (equal -10 (reduce (lambda (a e) (- a e)) vec 
			:initial-value 0)) "fold-left")
		(5am:is (equalp #(4 3 2 6 5) (map 'vector (lambda (e) 
			(+ e 2)) vec)) "map")
		(5am:is (equal '(2 1 0 4 3) (map 'list #'identity vec)) 
			"to-list (using map)")
		(5am:is (equal '(2 1 0 4 3) (coerce vec 'list)) 
			"to-list (using coerce)")
		(5am:is (equalp #(4 3 2 1 0) (sort vec #'>)) "sort")
    ))

(5am:test (test-2darrays :fixture fixc-collections)
	(let ((arr #2A((0 1 2) (3 4 5))))
		(5am:is (equalp #2A((0 0) (0 0)) (make-array '(2 2))) "make-array")
		(5am:is (equalp arr #2A((0 1 2) (3 4 5))) "equal")
		(5am:is (equal 2 (aref arr 0 2)) "aref")
		(5am:is (equal 2 (array-rank arr)) "array-rank")
		(5am:is (equal '(2 3) (array-dimensions arr)) "array-dimensions")
		(5am:is (equal 6 (array-total-size arr)) "size")
		(5am:is (equalp #(0 1 2 3 4 5) (make-array (array-total-size arr) 
			:displaced-to arr)) "to-vector")
    ))

(5am:test (test-alists :fixture fixc-collections)
	(let* ((vec (vector #\k #\p #\a #\e #\u #\k #\a))
			(alst (map 'list #'cons
				(map 'list (lambda (e) (format nil "'ltr ~a'" (mod e 5)))
					(loop for i from 0 to 6 collect i)) vec)))
		(5am:is (equalp '(("init" . #\i)) (acons "init" #\i '())) "alist-cons")
		(5am:is (listp alst) "listp")
		(5am:is (not (null alst)) "empty")
		(5am:is (equal '("'ltr 2'" . #\a) (assoc "'ltr 2'" alst :test 'equal)) "assoc")
		(5am:is (equal (length vec) (length alst)) "length")
		(5am:is (equalp '(("'ltr 0'" . #\k) ("'ltr 0'" . #\k) ("'ltr 1'" . #\p)
			("'ltr 1'" . #\a) ("'ltr 2'" . #\a) ("'ltr 3'" . #\e)
			("'ltr 4'" . #\u)) (sort alst (lambda (a b)
			(string< (car a) (car b))))) "sort")
	))

(5am:test (test-sets :fixture fixc-collections)
	(let* ((lst (list #\k #\p #\a #\e #\u #\k #\a))
			(set1 (reduce (lambda (a e) (adjoin e a :test #'equal)) 
                lst :initial-value '())))
		(5am:is (equal '(#\i) (adjoin #\i '())) "adjoin")
		(5am:is (equal set1 (reduce (lambda (a e) (adjoin e a :test #'equal))
			lst :initial-value '())) "equal")
		(5am:is (equal '(#\a #\e #\k #\p #\q #\u #\z) (sort (union 
			set1 '(#\q #\p #\z #\u)) #'char<)) "union")
		(5am:is (equal '(#\p #\u) (sort (intersection set1 
			'(#\q #\p #\z #\u)) #'char<)) "intersection")
		(5am:is (equal '(#\a #\e #\k) (sort (set-difference set1 
			'(#\q #\p #\z #\u)) #'char<)) "difference")
		(5am:is (equal '(#\a #\e #\k #\q #\z) (sort (set-exclusive-or 
			set1 '(#\q #\p #\z #\u)) #'char<)) "sort")
	))

(5am:test (test-hashtbls :fixture fixc-collections)
	(let* ((alst (map 'list #'cons
			(map 'list (lambda (e) (format nil "'ltr ~a'" (mod e 5)))
				(loop for i from 0 to 6 collect i)) 
				'(#\k #\p #\a #\e #\u #\k #\a)))
			(htbl (make-hash-table :test 'equal)))
		(5am:is (hash-table-p htbl) "hash-table-p")
		(mapc (lambda (e) (setf (gethash (car e) htbl) (cdr e))) alst)
		(5am:is (equal 5 (hash-table-count htbl)) "size")
		(5am:is (equal #\a (gethash "'ltr 2'" htbl)) "find")
		(5am:is (remhash "'ltr 0'" htbl) "remove")
		(5am:is (equal '("'ltr 1'" "'ltr 2'" "'ltr 3'" "'ltr 4'") (sort
			(loop for k being the hash-keys of htbl collect k) 
			#'string<)) "hashtbl keys")
		(5am:is (equal '(("'ltr 1'" . #\a) ("'ltr 2'" . #\a) ("'ltr 3'" . #\e)
			("'ltr 4'" . #\u)) (sort
			(mapcar (lambda (e) (cons e (gethash e htbl))) (loop for k being the hash-keys of htbl collect k)) 
			(lambda (a b) (string< (car a) (car b))))) "to-alist")
	))

(5am:test (test-queues :fixture fixc-collections)
	(let* ((vec (vector 25.7 0.1 78.5 52.3))
			(queue (queues:make-queue :simple-queue :minimum-size 4)))
		(map nil (lambda (e) (queues:qpush queue e)) vec)
		(5am:is (equal (length vec) (queues:qsize queue)) "size")
		(5am:is (equalp vec (slot-value queue 'queues::elements)) "contents")
		(5am:is (equal 25.7 (queues:qtop queue)) "peek")
		(5am:is (equal -5.0 (queues:qpush queue -5.0)) "enqueue")
		(5am:is (equal 25.7 (queues:qpop queue)) "dequeue")
	))

(5am:test (test-heaps :fixture fixc-collections)
	(let* ((vec (vector 25.7 0.1 78.5 52.3))
			(heap (queues:make-queue :priority-queue :comparison #'>)))
		(map nil (lambda (e) (queues:qpush heap e)) vec)
		(5am:is (equal (length vec) (queues:qsize heap)) "size")
		(5am:is (equal 0.1 (queues:qtop heap)) "peek")
		(5am:is (equal -5.0 (queues:qpush heap -5.0)) "enqueue")
		(5am:is (equal -5.0 (queues:qpop heap)) "dequeue")
	))
