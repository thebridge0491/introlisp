; Common Lisp - comments style conventions
; title       ;;;; Short title for block of code
; intro       ;;;  Description before block of code
; state       ;;   State of program or following code
; explanation ;    Regarding line on which it appears

(in-package :introlisp.practice/test)

(5am:def-suite tp-sequenceops
	:description "Sequenceops Properties suite")
(5am:in-suite tp-sequenceops)

(5am:def-fixture fixp-sequenceops ()
	(format t "~tSetUp-->~%")
	(&body)
	(format t "~t <--TearDown~%"))

(5am:test (prop-tabulate)
	(5am:for-all ((len (5am:gen-integer :min 0 :max 20)))
		(let* ((func (lambda (i) (+ i 2)))
				(ans (mapcar func (util:range-cnt 0 len))))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f func len)))) 
				'(seqops:tabulate-r seqops:tabulate-i seqops:tabulate-lp
				seqops:tabulate-f seqops:tabulate-u) :initial-value t))
			)))

(5am:test (prop-length)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((ans (length xs)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f xs)))) 
				'(seqops:length-r seqops:length-i seqops:length-lp
				seqops:length-f seqops:length-u) :initial-value t)))))

(5am:test (prop-nth)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 1 :max 20)))
			(ndx (5am:gen-integer :min 0 :max 20)))
		(if (< ndx (length xs))
		(let* ((ans (nth ndx xs)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f ndx xs)))) 
				'(seqops:nth-r seqops:nth-i seqops:nth-lp seqops:nth-f
				seqops:nth-u) :initial-value t))
			)
		(5am:is (equal t t)))))

(5am:test (prop-index-find)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
			(el (5am:gen-integer)))
		(let* ((pred (lambda (e) (equal el e))) (ans-idx (position el xs))
				(ans-find (find-if pred xs)))
			(5am:is (reduce (lambda (a tup) (let* ((fn-idx (car tup))
					(fn-find (cdr tup)))
				(and a (equal ans-idx (funcall fn-idx pred xs))
					(equal ans-find (funcall fn-find pred xs)))))
				'((seqops:index-r . seqops:find-r)
				(seqops:index-i . seqops:find-i)
				(seqops:index-lp . seqops:find-lp)
				(seqops:index-f . seqops:find-f)
				(seqops:index-u . seqops:find-u)) :initial-value t))
			)))

(5am:test (prop-min-max)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 1 :max 20))))
		(let* ((ans-min (apply #'min xs)) (ans-max (apply #'max xs)))
			(5am:is (reduce (lambda (a tup) (let* ((fn-min (car tup)) 
					(fn-max (cdr tup)))
				(and a (equal ans-min (apply fn-min xs))
					(equal ans-max (apply fn-max xs)))))
				'((seqops:min-r . seqops:max-r) (seqops:min-i . seqops:max-i) 
				(seqops:min-lp . seqops:max-lp)
				(seqops:min-f . seqops:max-f)
				(seqops:min-u . seqops:max-u)) :initial-value t)))))

(5am:test (prop-reverse)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((ans (reverse xs)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f xs))))
				'(seqops:reverse-r seqops:reverse-i seqops:reverse-lp
				seqops:reverse-f seqops:reverse-u) :initial-value t)))))

(5am:test (prop-copy)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((ans (copy-seq xs)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f xs))))
				'(seqops:copy-r seqops:copy-i seqops:copy-lp seqops:copy-f
				seqops:copy-u) :initial-value t)))))

(5am:test (prop-take-drop)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
			(n (5am:gen-integer :min 0 :max 20)))
		(if (<= n (length xs))
		(let* ((ans-take (subseq xs 0 n)) (ans-drop (nthcdr n xs)))
			(5am:is (reduce (lambda (a tup) (let ((fn-take (car tup)) 
					(fn-drop (cdr tup)))
				(and a (equal ans-take (funcall fn-take n xs))
					(equal ans-drop (funcall fn-drop n xs)))))
				'((seqops:take-i . seqops:drop-i) 
				(seqops:take-lp . seqops:drop-lp)
				(seqops:take-f . seqops:drop-f)
				(seqops:take-u . seqops:drop-u)) :initial-value t))
			)
		(5am:is (equal t t)))))

(5am:test (prop-any-every)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((pred (lambda (e) (equal 0 (mod e 2)))) (ans-any (some pred xs))
				(ans-every (every pred xs)))
			(5am:is (reduce (lambda (a tup) (let* ((fn-any (car tup))
					(fn-every (cdr tup)))
				(and a (equal ans-any (funcall fn-any pred xs))
					(equal ans-every (funcall fn-every pred xs)))))
				'((seqops:any-r . seqops:every-r)
				(seqops:any-i . seqops:every-i)
				(seqops:any-lp . seqops:every-lp)
				(seqops:any-f . seqops:every-f)
				(seqops:any-u . seqops:every-u)) :initial-value t))
			)))

(5am:test (prop-map)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((proc (lambda (e) (+ e 2))) (ans (mapcar proc xs)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f proc xs)))) 
				'(seqops:map-r seqops:map-i seqops:map-lp seqops:map-f
				seqops:map-u) :initial-value t))
			)))
#|
(5am:test (prop-for-each)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((proc (lambda (e) (format t "~a " e))) (ans (map nil proc xs)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f proc xs)))) 
				'(seqops:for-each-r seqops:for-each-i seqops:for-each-lp
				seqops:for-each-f seqops:for-each-u) :initial-value t))
			)))
|#

(5am:test (prop-filter-remove)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((pred (lambda (e) (equal 0 (mod e 2)))) (ans-filter (remove-if-not pred xs))
				(ans-remove (remove-if pred xs)))
			(5am:is (reduce (lambda (a tup) (let* ((fn-filter (car tup))
					(fn-remove (cdr tup)))
				(and a (equal ans-filter (funcall fn-filter pred xs))
					(equal ans-remove (funcall fn-remove pred xs)))))
				'((seqops:filter-r . seqops:remove-r)
				(seqops:filter-i . seqops:remove-i)
				(seqops:filter-lp . seqops:remove-lp)
				(seqops:filter-f . seqops:remove-f)
				(seqops:filter-u . seqops:remove-u)) :initial-value t))
			)))

(5am:test (prop-fold-left)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((corp #'+) (ans (reduce corp xs :initial-value 0)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f corp 0 xs)))) 
				'(seqops:fold-left-r seqops:fold-left-i seqops:fold-left-lp)
				:initial-value t))
			)))

(5am:test (prop-fold-right)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((proc #'-) (ans (reduce proc xs :initial-value 0 :from-end t)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f proc 0 xs)))) 
				'(seqops:fold-right-r seqops:fold-right-i seqops:fold-right-lp)
				:initial-value t))
			)))

(5am:test (prop-unfold-right)
	(5am:for-all ((x (5am:gen-integer :min 0 :max 25)))
		(let* ((pred (lambda (tup) (< (cdr tup) (car tup))))
			(func (lambda (tup) (car tup)))
			(seed (cons 0 x)) (gen (lambda (tup)
				(cons (1+ (car tup)) (cdr tup))))
			(ans (unfold-right pred func gen seed)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f pred func gen seed)))) 
				'(seqops:unfold-right-i seqops:unfold-right-lp)
				:initial-value t))
			)))

(5am:test (prop-unfold-left)
	(5am:for-all ((x (5am:gen-integer :min 0 :max 25)))
		(let* ((pred (lambda (tup) (< (cdr tup) (car tup))))
			(func (lambda (tup) (car tup)))
			(seed (cons 0 x)) (gen (lambda (tup)
				(cons (1+ (car tup)) (- (cdr tup) (car tup)))))
			(ans (reverse (unfold-right pred func gen seed))))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f pred func gen seed)))) 
				'(seqops:unfold-left-r seqops:unfold-left-lp)
				:initial-value t))
			)))

(5am:test (prop-is-ordered)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((cmp #'<=)
			(verify (lambda (lst cmp) (every cmp lst (cdr lst))))
			(ans (funcall verify xs cmp)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f xs :cmp cmp)))) 
				'(seqops:is-ordered-r seqops:is-ordered-i seqops:is-ordered-lp
				seqops:is-ordered-f seqops:is-ordered-u)
				:initial-value t))
			)))


(5am:test (prop-append)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))) (ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((ans (append xs ys)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f xs ys)))) 
				'(seqops:append-r seqops:append-i seqops:append-lp
				seqops:append-f seqops:append-u) :initial-value t))
			)))

(5am:test (prop-interleave)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))) (ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((extra (if (> (length xs) (length ys))
				(nthcdr (length ys) xs) (nthcdr (length xs) ys)))
				(ans (append (mapcan (lambda (x y) (list x y)) xs ys) extra)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f xs ys)))) 
				'(seqops:interleave-r seqops:interleave-i seqops:interleave-lp
				seqops:interleave-f seqops:interleave-u)
				:initial-value t))
			)))

(5am:test (prop-map2)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))) (ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((proc (lambda (e1 e2) (+ e1 e2 2))) (ans (mapcar proc xs ys)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f proc xs ys)))) 
				'(seqops:map2-r seqops:map2-i seqops:map2-lp seqops:map2-f
				seqops:map2-u) :initial-value t))
			)))

(5am:test (prop-zip)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))) (ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((ans (mapcar #'list xs ys)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f xs ys)))) 
				'(seqops:zip-r seqops:zip-i seqops:zip-lp seqops:zip-f
				seqops:zip-u) :initial-value t))
			)))

(5am:test (prop-unzip)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))) (ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((zlst (mapcar #'list xs ys)) (ans (values (mapcar #'car zlst) (mapcar #'cadr zlst))))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f zlst)))) 
				'(seqops:unzip-i seqops:unzip-lp seqops:unzip-m seqops:unzip-f seqops:unzip-u)
				:initial-value t))
			)))

(5am:test (prop-concat)
	(5am:for-all ((nlst (5am:gen-list :length (5am:gen-integer :min 0 :max 20) :elements (5am:gen-list :length (5am:gen-integer :min 0 :max 10)))))
		(let* ((ans (apply #'concatenate 'list nlst)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans (funcall f nlst)))) 
				'(seqops:concat-r seqops:concat-i seqops:concat-lp 
				seqops:concat-a seqops:concat-f seqops:concat-u)
				:initial-value t))
			)))


(5am:test (prop-any-every-v)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(zs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((pred-any2 (lambda (e1 e2) (or (evenp e1) (evenp e2))))
			(pred-any3 (lambda (e1 e2 e3) (or (evenp e1) (evenp e2)
				(evenp e3))))
			(pred-every2 (lambda (e1 e2) (and (oddp e1) (oddp e2))))
			(pred-every3 (lambda (e1 e2 e3) (and (oddp e1) (oddp e2)
				(oddp e3))))
			(ans-any2 (some pred-any2 xs ys))
			(ans-any3 (some pred-any3 xs ys zs))
			(ans-every2 (every pred-every2 xs ys))
			(ans-every3 (every pred-every3 xs ys zs)))
			(5am:is (reduce (lambda (a tup) (let* ((fn-any (car tup))
					(fn-every (cdr tup)))
				(and a (equal ans-any2 (funcall fn-any pred-any2 xs ys))
					(equal ans-any3 (funcall fn-any pred-any3 xs ys zs))
					(equal ans-every2 (funcall fn-every pred-every2 xs ys))
					(equal ans-every3
						(funcall fn-every pred-every3 xs ys zs)))))
				'((seqops:any-rv . seqops:every-rv)
				(seqops:any-iv . seqops:every-iv)
				(seqops:any-lpv . seqops:every-lpv)
				(seqops:any-fv . seqops:every-fv)
				(seqops:any-uv . seqops:every-uv)) :initial-value t))
			)))

(5am:test (prop-map-v)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(zs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((proc2 (lambda (a b) (list (+ a 2) (+ b 2))))
			(proc3 (lambda (a b c) (list (+ a 2) (+ b 2) (+ c 2))))
			(ans2 (mapcar proc2 xs ys)) (ans3 (mapcar proc3 xs ys zs)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans2 (funcall f proc2 xs ys))
					(equal ans3 (funcall f proc3 xs ys zs)))) 
				'(seqops:map-rv seqops:map-iv seqops:map-lpv
				seqops:map-fv seqops:map-uv) 
				:initial-value t))
			)))
#|
(5am:test (prop-for-each-v)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(zs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((proc2 (lambda (a b) (format t "~a ~a" a b)))
			(proc3 (lambda (a b c) (format t "~a ~a ~a" a b c))) 
			(ans2 (map nil proc2 xs ys)) (ans3 (map nil proc3 xs ys zs)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans2 (funcall f proc2 xs ys))
					(equal ans3 (funcall f proc3 xs ys zs)))) 
				'(seqops:for-each-rv seqops:for-each-iv seqops:for-each-lpv
				seqops:for-each-fv seqops:for-each-uv)
				:initial-value t))
			)))
|#

(5am:test (prop-fold-left-v)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(zs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((corp2 (lambda (a e1 e2) (+ a e1 e2)))
			(corp3 (lambda (a e1 e2 e3) (- a e1 e2 e3)))
			(ans2 (reduce (lambda (a x-y) (+ a (car x-y) (cadr x-y))) 
				(mapcar #'list xs ys) :initial-value 0))
			(ans3 (reduce (lambda (a x-y-z) (- a (car x-y-z) (cadr x-y-z) 
				(caddr x-y-z))) (mapcar #'list xs ys zs) :initial-value 0)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans2 (funcall f corp2 0 xs ys))
					(equal ans3 (funcall f corp3 0 xs ys zs)))) 
				'(seqops:fold-left-rv seqops:fold-left-iv seqops:fold-left-lpv)
				:initial-value t))
			)))

(5am:test (prop-fold-right-v)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(zs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((proc2 (lambda (e1 e2 a) (+ (+ e1 e2) a)))
			(proc3 (lambda (e1 e2 e3 a) (- (+ e1 e2 e3) a)))
			(ans2 (reduce (lambda (x-y a) (+ (+ (car x-y) (cadr x-y)) a)) 
				(mapcar #'list xs ys) :initial-value 0 :from-end t))
			(ans3 (reduce (lambda (x-y-z a) (- (+ (car x-y-z) (cadr x-y-z) 
				(caddr x-y-z)) a)) (mapcar #'list xs ys zs) :initial-value 0
				:from-end t)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans2 (funcall f proc2 0 xs ys))
					(equal ans3 (funcall f proc3 0 xs ys zs)))) 
				'(seqops:fold-right-rv seqops:fold-right-iv
				seqops:fold-right-lpv)
				:initial-value t))
			)))

(5am:test (prop-append-v)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(zs (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((ans2 (append xs ys)) (ans3 (append xs ys zs)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans2 (funcall f xs ys))
					(equal ans3 (funcall f xs ys zs)))) 
				'(seqops:append-rv seqops:append-iv seqops:append-lpv
				seqops:append-fv seqops:append-uv) :initial-value t))
			)))

(5am:test (prop-zip-v)
	(5am:for-all ((xs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(ys (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(zs (5am:gen-list :length (5am:gen-integer :min 0 :max 20)))
		(ws (5am:gen-list :length (5am:gen-integer :min 0 :max 20))))
		(let* ((ans3 (mapcar #'list xs ys zs))
			(ans4 (mapcar #'list xs ys zs ws)))
			(5am:is (reduce (lambda (a f)
				(and a (equal ans3 (funcall f xs ys zs))
					(equal ans4 (funcall f xs ys zs ws)))) 
				'(seqops:zip-rv seqops:zip-iv seqops:zip-lpv
				seqops:zip-fv seqops:zip-uv) :initial-value t))
			)))
