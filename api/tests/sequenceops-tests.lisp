; Common Lisp - comments style conventions
; title       ;;;; Short title for block of code
; intro       ;;;  Description before block of code
; state       ;;   State of program or following code
; explanation ;    Regarding line on which it appears

(in-package :introlisp.practice/test)

(5am:def-suite tc-sequenceops
	:description "Sequenceops Tests suite")
(5am:in-suite tc-sequenceops)

(5am:def-fixture fixc-sequenceops ()
	(format t "~tSetUp-->~%")
	(&body)
	(format t "~t <--TearDown~%"))

(5am:test (test-tabulate :fixture fixc-sequenceops)
	(mapcar (lambda (len)
		(let* ((func (lambda (e) (/ 32 (expt 2 e))))
			(ans (mapcar func (util:range-cnt 0 len))))
		(mapcar (lambda (f)
			(5am:is (equal ans (funcall f func len))))
			'(seqops:tabulate-r seqops:tabulate-i seqops:tabulate-lp
			seqops:tabulate-f seqops:tabulate-u))))
		'(0 5 10)))

(5am:test (test-length :fixture fixc-sequenceops)
	(mapcar (lambda (len)
		(let* ((xs (util:range-cnt 0 len)) (ans (length xs)))
		(mapcar (lambda (f)
			(5am:is (equal ans (funcall f xs))))
			'(seqops:length-r seqops:length-i seqops:length-lp
			seqops:length-f seqops:length-u))))
		'(3 5 7)))

(5am:test (test-nth :fixture fixc-sequenceops)
    (mapcar (lambda (f) (progn
		(5am:is (equal (nth 3 lst) (funcall f 3 lst)))
		(5am:is (equal (nth 3 revlst) (funcall f 3 revlst)))
		nil))
		'(seqops:nth-r seqops:nth-i seqops:nth-lp seqops:nth-f
		seqops:nth-u)))

(5am:test (test-index-find :fixture fixc-sequenceops)
	(mapcar (lambda (tup)
		(let* ((el 3) (pred (lambda (e) (equal e el)))
				(fn-idx (car tup)) (fn-find (cdr tup)))
			(5am:is (equal (position el lst) (funcall fn-idx pred lst)))
			(5am:is (equal (position el revlst) (funcall fn-idx pred revlst)))
			(5am:is (equal (find-if pred lst) (funcall fn-find pred lst)))
			(5am:is (equal (find-if pred revlst) (funcall fn-find pred revlst)))))
		'((seqops:index-r . seqops:find-r) (seqops:index-i . seqops:find-i) (seqops:index-lp . seqops:find-lp)
		(seqops:index-f . seqops:find-f)
		(seqops:index-u . seqops:find-u))))

(5am:test (test-min-max :fixture fixc-sequenceops)
	(mapcar (lambda (tup)
		(let* ((fn-min (car tup)) (fn-max (cdr tup)))
			(5am:is (equal (apply #'min lst) (apply fn-min lst)))
			(5am:is (equal (apply #'min revlst) (apply fn-min revlst)))
			(5am:is (equal (apply #'max lst) (apply fn-max lst)))
			(5am:is (equal (apply #'max revlst) (apply fn-max revlst)))))
		'((seqops:min-r . seqops:max-r) (seqops:min-i . seqops:max-i) (seqops:min-lp . seqops:max-lp) (seqops:min-f . seqops:max-f)
		(seqops:min-u . seqops:max-u))))

(5am:test (test-reverse :fixture fixc-sequenceops)
    (mapcar (lambda (f) (progn
		(5am:is (equal revlst (funcall f lst)))
		(5am:is (equal lst (funcall f revlst)))
		nil))
		'(seqops:reverse-r seqops:reverse-i seqops:reverse-lp
		seqops:reverse-f seqops:reverse-u)))

(5am:test (test-copy :fixture fixc-sequenceops)
    (mapcar (lambda (f) (progn
		(5am:is (equal lst (funcall f lst)))
		(5am:is (equal revlst (funcall f revlst)))
		nil))
		'(seqops:copy-r seqops:copy-i seqops:copy-lp seqops:copy-f
		seqops:copy-u)))

(5am:test (test-take-drop :fixture fixc-sequenceops)
    (mapcar (lambda (tup)
		(let ((fn-take (car tup)) (fn-drop (cdr tup)))
		(5am:is (equal (subseq lst 0 3) (funcall fn-take 3 lst)))
		(5am:is (equal (subseq revlst 0 3) (funcall fn-take 3 revlst)))
		(5am:is (equal (nthcdr 3 lst) (funcall fn-drop 3 lst)))
		(5am:is (equal (nthcdr 3 revlst) (funcall fn-drop 3 revlst)))
		))
		'((seqops:take-i . seqops:drop-i) (seqops:take-lp . seqops:drop-lp)
		(seqops:take-f . seqops:drop-f) (seqops:take-u . seqops:drop-u))))

(5am:test (test-any-every :fixture fixc-sequenceops)
	(mapcar (lambda (tup)
		(let* ((fn-any (car tup)) (fn-every (cdr tup)))
			(5am:is (equal (some #'integerp '()) 
				(funcall fn-any #'integerp '())))
			(5am:is (equal (every #'integerp '())
				(funcall fn-every #'integerp '())))
			
			(5am:is (equal (some #'integerp '(1 2 #\a)) 
				(funcall fn-any #'integerp '(1 2 #\a))))
			(5am:is (equal (some #'null '(() (1) (2 3))) 
				(funcall fn-any #'null '(() (1) (2 3)))))
			(5am:is (equal (every #'integerp '(1 2))
				(funcall fn-every #'integerp '(1 2))))
			(5am:is (equal (every #'listp '(0 (1) (#\a)))
				(funcall fn-every #'listp '(0 (1) (#\a)))))))
		'((seqops:any-r . seqops:every-r) (seqops:any-i . seqops:every-i)
			(seqops:any-lp . seqops:every-lp)
			(seqops:any-f . seqops:every-f)
			(seqops:any-u . seqops:every-u))))

(5am:test (test-map :fixture fixc-sequenceops)
	(mapcar (lambda (xs)
		(let* ((proc (lambda (e) (+ e 2))) (ans (mapcar proc xs)))
		(mapcar (lambda (f)
			(5am:is (equal ans (funcall f proc xs))))
			'(seqops:map-r seqops:map-i seqops:map-lp seqops:map-f
			seqops:map-u))))
		(list lst revlst)))

(5am:test (test-for-each :fixture fixc-sequenceops)
	(mapcar (lambda (xs)
		(let* ((proc (lambda (e) (format t "~a " e))) (ans (map nil proc xs)))
		(mapcar (lambda (f)
			(5am:is (equal ans (funcall f proc xs))))
			'(seqops:for-each-r seqops:for-each-i seqops:for-each-lp
			seqops:for-each-f seqops:for-each-u))))
		(list lst revlst)))

(5am:test (test-filter-remove :fixture fixc-sequenceops)
    (mapcar (lambda (xs)
		(mapcar (lambda (tup)
			(let* ((fn-filter (car tup)) (fn-remove (cdr tup)))
			(5am:is (equal (remove-if-not #'evenp xs)
				(funcall fn-filter #'evenp xs)))
			(5am:is (equal (remove-if #'evenp xs)
				(funcall fn-remove #'evenp xs)))
			))
			'((seqops:filter-r . seqops:remove-r)
				(seqops:filter-i . seqops:remove-i)
				(seqops:filter-lp . seqops:remove-lp)
				(seqops:filter-f . seqops:remove-f)
				(seqops:filter-u . seqops:remove-u))))
		(list lst revlst)))

(5am:test (test-fold-left :fixture fixc-sequenceops)
	(mapcar (lambda (xs)
		(let* ((corp1 (lambda (a e) (+ a e))) (corp2 (lambda (a e) (- a e)))
			(ans1 (reduce corp1 xs :initial-value 0))
			(ans2 (reduce corp2 xs :initial-value 0)))
		(mapcar (lambda (f)
			(5am:is (equal ans1 (funcall f corp1 0 xs)))
			(5am:is (equal ans2 (funcall f corp2 0 xs))))
			'(seqops:fold-left-r seqops:fold-left-i seqops:fold-left-lp))))
		(list lst revlst)))

(5am:test (test-fold-right :fixture fixc-sequenceops)
	(mapcar (lambda (xs)
		(let* ((proc1 (lambda (e a) (+ e a))) (proc2 (lambda (e a) (- e a)))
			(ans1 (reduce proc1 xs :initial-value 0 :from-end t))
			(ans2 (reduce proc2 xs :initial-value 0 :from-end t)))
		(mapcar (lambda (f)
			(5am:is (equal ans1 (funcall f proc1 0 xs)))
			(5am:is (equal ans2 (funcall f proc2 0 xs))))
			'(seqops:fold-right-r seqops:fold-right-i seqops:fold-right-lp))))
		(list lst revlst)))

(5am:test (test-unfold-right :fixture fixc-sequenceops)
	(let* ((pred (lambda (tup) (= (cdr tup) 0)))
		(func (lambda (tup) (car tup)))
		(seed1 '(0 . 10)) (gen1 (lambda (tup)
			(cons (+ (car tup) 1) (- (cdr tup) (car tup)))))
		(seed2 '(0 . -10)) (gen2 (lambda (tup)
			(cons (+ (car tup) 1) (+ (cdr tup) (car tup)))))
		(ans1 (unfold-right pred func gen1 seed1))
		(ans2 (unfold-right pred func gen2 seed2)))
	(mapcar (lambda (f)
		(5am:is (equal ans1 (funcall f pred func gen1 seed1)))
		(5am:is (equal ans2 (funcall f pred func gen2 seed2))))
		'(seqops:unfold-right-i seqops:unfold-right-lp))))

(5am:test (test-unfold-left :fixture fixc-sequenceops)
	(let* ((pred (lambda (tup) (= (cdr tup) 0)))
		(func (lambda (tup) (car tup)))
		(seed1 '(0 . 10)) (gen1 (lambda (tup)
			(cons (+ (car tup) 1) (- (cdr tup) (car tup)))))
		(seed2 '(0 . 2)) (gen2 (lambda (tup)
			(cons (+ (car tup) 1) (- (car tup) (cdr tup)))))
		(ans1 (reverse (unfold-right pred func gen1 seed1)))
		(ans2 (reverse (unfold-right pred func gen2 seed2))))
	(mapcar (lambda (f)
		(5am:is (equal ans1 (funcall f pred func gen1 seed1)))
		(5am:is (equal ans2 (funcall f pred func gen2 seed2))))
		'(seqops:unfold-left-r seqops:unfold-left-lp))))

(5am:test (test-is-ordered :fixture fixc-sequenceops)
	(mapcar (lambda (xs)
		(let* ((cmp1 #'<=) (cmp2 #'>=)
			(verify (lambda (lst cmp) (every cmp lst (cdr lst))))
			(ans1 (funcall verify xs cmp1))
			(ans2 (funcall verify xs cmp2)))
		(mapcar (lambda (f)
			(5am:is (equal ans1 (funcall f xs :cmp cmp1)))
			(5am:is (equal ans2 (funcall f xs :cmp cmp2))))
			'(seqops:is-ordered-r seqops:is-ordered-i seqops:is-ordered-lp
			seqops:is-ordered-f seqops:is-ordered-u))))
		(list lst revlst)))


(5am:test (test-append :fixture fixc-sequenceops)
	(mapcar (lambda (xs)
		(let* ((nines '(9 9 9 9)) (ans (append xs nines)))
		(mapcar (lambda (f)
			(5am:is (equal ans (funcall f xs nines))))
			'(seqops:append-r seqops:append-i seqops:append-lp
			seqops:append-f seqops:append-u))))
		(list lst revlst)))

(5am:test (test-interleave :fixture fixc-sequenceops)
	(mapcar (lambda (f)
		(5am:is (equal '(0 9 1 9 2 9 3 9 4) (funcall f lst '(9 9 9 9))))
		(5am:is (equal '(4 9 3 9 2 9 1 9 0) (funcall f revlst '(9 9 9 9)))))
		'(seqops:interleave-r seqops:interleave-i seqops:interleave-lp
		seqops:interleave-f seqops:interleave-u)))

(5am:test (test-map2 :fixture fixc-sequenceops)
	(mapcar (lambda (xs)
		(let* ((proc (lambda (e1 e2) (+ e1 e2 2))) (ans (mapcar proc xs xs)))
		(mapcar (lambda (f)
			(5am:is (equal ans (funcall f proc xs xs))))
			'(seqops:map2-r seqops:map2-i seqops:map2-lp seqops:map2-f
			seqops:map2-u))))
		(list lst revlst)))

(5am:test (test-zip :fixture fixc-sequenceops)
	(let ((lst1 '(0 1 2)) (lst2 '(20 30)) (lst3 '(0 (1 2))))
	(mapcar (lambda (f)
		(5am:is (equal (mapcar #'list lst1 lst2) (funcall f lst1 lst2)))
		(5am:is (equal (mapcar #'list lst3 lst2) (funcall f lst3 lst2))))
		'(seqops:zip-r seqops:zip-i seqops:zip-lp seqops:zip-f
		seqops:zip-u))))

(5am:test (test-unzip :fixture fixc-sequenceops)
	(let ((zlst1 '((0 20) (1 30))) (zlst2 '((0 20) (1 30) (#\a #\b)))
		(lst1 '(0 1)) (lst2 '(20 30)) (lst3 '(0 1 #\a)) (lst4 '(20 30 #\b)))
	(mapcar (lambda (f)
		(5am:is (multiple-value-bind (xs ys) (funcall f zlst1) (and (equal lst1 xs) (equal lst2 ys))))
		(5am:is (multiple-value-bind (xs ys) (funcall f zlst2) (and (equal lst3 xs) (equal lst4 ys))))
		)
		'(seqops:unzip-i seqops:unzip-lp seqops:unzip-m seqops:unzip-f
		seqops:unzip-u))))

(5am:test (test-concat :fixture fixc-sequenceops)
	(let ((nlst1 '((0 1 2) (20 30))) (nlst2 '((0 (1 #\a)) (20 (30)))))
	(mapcar (lambda (f)
		(5am:is (equal (apply #'concatenate 'list nlst1) (funcall f nlst1)))
		(5am:is (equal (apply #'concatenate 'list nlst2) (funcall f nlst2)))
		)
		'(seqops:concat-r seqops:concat-i seqops:concat-lp seqops:concat-a
		seqops:concat-f seqops:concat-u))))
